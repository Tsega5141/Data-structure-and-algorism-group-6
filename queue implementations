#include <iostream> includes the standard input-output stream library, which enables the use of cout and cin for output and input.
using namespace std; simplifies the code by allowing us to use standard library functions without prefixing them with std

#define SIZE 5 defines a macro SIZE #define SIZE 5 defines a macro SIZE with the value 5, which is the maximum capacity of the queue.Macros like this are often used to set fixed values that don’t change, making the code more readable and maintainable
The CircularQueue() constructor initializes front and rear to -1, indicating that the queue is empty when it is first created.
class CircularQueue {
private:
int items[SIZE], front, rear;
The CircularQueue class represents the circular queue data structure.
int items[SIZE] is an array that will hold the queue elements, with a maximum of SIZE elements.
int front and int rear are used to keep track of the front and rear positions in the queue. 
Initially, both front and rear are set to -1, indicating an empty queue.
Constructor: CircularQueue()
Initializes the circular queue. The front and rear pointers are both set to -1, indicating that the queue is empty initially.
isFull()
Checks if the circular queue is full:
(front == 0 && rear == SIZE - 1): The queue is full if the front pointer is at the start of the array and the rear pointer is at the end.
(rear == (front - 1) % (SIZE - 1)): The queue is also full if rear is directly behind front in a circular manner, meaning that adding an element would overwrite the front of the queue.
isEmpty()
Checks if the queue is empty by seeing if front is equal to -1. If front is -1, there are no elements in the queue.
enqueue(int value)
Adds an element to the queue if it's not full:
If isFull() returns true, it outputs that the queue is full and doesn't add the new element.
If the queue is initially empty (front == -1), both front and rear are set to 0, positioning them at the start of the queue.
If rear is at the end of the array (SIZE - 1) but the front pointer is not at 0, it wraps rear back to 0 to use available space.
Otherwise, rear is incremented normally.
The new element value is stored at the rear position, and a message is displayed confirming the insertion.
dequeue()
if (isEmpty()) { cout << "Queue is empty!\n"; return; }
Checks if the queue is empty by calling isEmpty(). If true, it outputs "Queue is empty!" and exits the function without doing anything further.
cout << "Deleted " << items[front] << "\n";
Prints the element at the front of the queue, indicating it will be removed.
if (front == rear) { front = rear = -1; }
Checks if there is only one element in the queue (when front and rear are the same). If true, it sets both front and rear to -1, indicating the queue is now empty after removing this element.
else if (front == SIZE - 1) { front = 0; }
Checks if the front pointer is at the end of the array (SIZE - 1). If so, it wraps front back to 0 to use available space at the start (circular behavior).
else { front++; }
If neither of the above conditions are true, it simply increments front to the next position, moving it forward by one.
display()
 if (isEmpty()) { cout << "Queue is empty!\n"; return; }
Checks if the queue is empty by calling isEmpty(). If true, it outputs "Queue is empty!" and exits the function, as there’s nothing to display.
After this check, the rest of the display() function (not shown here) would likely iterate over the elements from front to rear to print the contents of the queue in the correct order. This part would handle circular behavior by wrapping around when the end of the array is reached.
